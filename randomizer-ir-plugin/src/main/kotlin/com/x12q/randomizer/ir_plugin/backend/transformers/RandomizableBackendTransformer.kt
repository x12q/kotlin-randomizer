package com.x12q.randomizer.ir_plugin.backend.transformers

import com.x12q.randomizer.lib.annotations.Randomizable
import com.x12q.randomizer.ir_plugin.backend.transformers.accessor.*
import com.x12q.randomizer.ir_plugin.backend.transformers.accessor.std_lib.collections.ListAccessor
import com.x12q.randomizer.ir_plugin.backend.transformers.accessor.std_lib.collections.MapAccessor
import com.x12q.randomizer.ir_plugin.backend.transformers.accessor.std_lib.collections.SetAccessor
import com.x12q.randomizer.ir_plugin.backend.transformers.accessor.function_n.Function0Accessor
import com.x12q.randomizer.ir_plugin.backend.transformers.accessor.function_n.Function1Accessor
import com.x12q.randomizer.ir_plugin.backend.transformers.accessor.rd_lib.*
import com.x12q.randomizer.ir_plugin.backend.transformers.accessor.std_lib.RandomAccessor
import com.x12q.randomizer.ir_plugin.backend.transformers.accessor.std_lib.collections.ArrayAccessor
import com.x12q.randomizer.ir_plugin.backend.transformers.reporting.*
import com.x12q.randomizer.ir_plugin.backend.transformers.random_function.RandomFunctionMetaData
import com.x12q.randomizer.ir_plugin.backend.utils.*
import com.x12q.randomizer.ir_plugin.base.BaseObjects
import com.x12q.randomizer.ir_plugin.util.crashOnNull
import com.x12q.randomizer.ir_plugin.util.runSideEffect
import com.x12q.randomizer.ir_plugin.util.stopAtFirstNotNull
import com.x12q.randomizer.lib.*
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.backend.common.ir.addExtensionReceiver
import org.jetbrains.kotlin.backend.common.lower.DeclarationIrBuilder
import org.jetbrains.kotlin.backend.common.lower.irThrow
import org.jetbrains.kotlin.descriptors.DescriptorVisibilities
import org.jetbrains.kotlin.descriptors.Modality.*
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.backend.js.utils.typeArguments
import org.jetbrains.kotlin.ir.builders.*
import org.jetbrains.kotlin.ir.builders.declarations.IrFunctionBuilder
import org.jetbrains.kotlin.ir.builders.declarations.addValueParameter
import org.jetbrains.kotlin.ir.builders.declarations.buildFun
import org.jetbrains.kotlin.ir.builders.declarations.buildVariable
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.expressions.*
import org.jetbrains.kotlin.ir.expressions.impl.IrFunctionExpressionImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrThrowImpl
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.symbols.IrClassifierSymbol
import org.jetbrains.kotlin.ir.symbols.IrTypeParameterSymbol
import org.jetbrains.kotlin.ir.types.*
import org.jetbrains.kotlin.ir.types.impl.IrSimpleTypeImpl
import org.jetbrains.kotlin.ir.types.impl.originalKotlinType
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.name.SpecialNames
import javax.inject.Inject

/**
 * Order of priority: random context > generic factory function
 */
class RandomizableBackendTransformer @Inject constructor(
    override val pluginContext: IrPluginContext,
    private val randomAccessor: RandomAccessor,
    private val randomConfigAccessor: RandomConfigAccessor,
    private val defaultRandomConfigAccessor: DefaultRandomConfigAccessor,
    private val function0Accessor: Function0Accessor,
    private val function1Accessor: Function1Accessor,
    private val randomContextBuilderAccessor: RandomizerContextBuilderAccessor,
    private val randomContextBuilderImpAccessor: RandomContextBuilderImpAccessor,
    private val randomizerCollectionAccessor: RandomizerCollectionAccessor,
    private val randomContextAccessor: RandomContextAccessor,
    private val unableToMakeRandomExceptionAccessor: UnableToMakeRandomExceptionAccessor,
    private val classRandomizerAccessor: ClassRandomizerAccessor,
    private val classRandomizerUtilAccessor: ClassRandomizerUtilAccessor,
    private val listAccessor: ListAccessor,
    private val mapAccessor: MapAccessor,
    private val setAccessor: SetAccessor,
    private val arrayAccessor: ArrayAccessor,
) : RDBackendTransformer() {

    override fun visitClassNew(declaration: IrClass): IrStatement {

        val annotation = declaration.getAnnotation(BaseObjects.randomizableFqName)
        if (annotation != null) {
            val companionObj = declaration.companionObject()
            if (companionObj != null) {
                completeRandomFunction1(companionObj, declaration)
                completeRandomFunction2(companionObj, declaration)
            }
        }
        return super.visitClassNew(declaration)
    }


    /**
     * Check if a function is a random() function generated by the front end.
     * TODO this check is not strict enough, it can on paper mistake some other function as the intended one.
     */
    private fun isGeneratedRandomFunction(function: IrSimpleFunction): Boolean {
        val origin = function.origin
        val isGeneratedByRandomizerPlugin =
            (origin is IrDeclarationOrigin.GeneratedByPlugin) && (origin.pluginKey == BaseObjects.randomizableDeclarationKey)
        val nameIsRandom = function.name == BaseObjects.randomFunctionName
        return isGeneratedByRandomizerPlugin && nameIsRandom
    }

    /**
     * The purpose of this transformation is:
     * - add randomizers for generic type at call side of random() functions
     *
     * Explanation:
     * - Only at call side that the concrete type of generic type is known.
     * - Therefore, only at call side there's enough information to generate randomizers for generic type.
     */
    override fun visitCall(expression: IrCall): IrExpression {

        val function = expression.symbol.owner

        if (isGeneratedRandomFunction(function)) {

            val randomFunction = function

            val randomizersParam = function.valueParameters.firstOrNull {
                it.name == BaseObjects.randomContextBuilderConfigFunctionParamName
            }
            if (randomizersParam != null) {
                val providedRandomizersArgument = expression.getValueArgument(randomizersParam.index)

                /**
                 * Extract the randomizers lambda from the random function, use the default if none is available.
                 * this lambda signature is: randomizers = RandomContextBuilder.{}
                 */
                val randomizersLambda = if (providedRandomizersArgument != null) {
                    (providedRandomizersArgument as? IrFunctionExpression)?.function
                } else {
                    val defaultRandomizers =
                        (randomizersParam.defaultValue?.expression as? IrFunctionExpression)?.function
                    val newDefault = defaultRandomizers?.let { cloneFunction(it, pluginContext) }

                    runSideEffect {
                        // replace the default argument with a copy of it

                        val newDefaultArg = newDefault?.let {
                            makeIrFunctionExpr(
                                newDefault,
                                pluginContext.irBuiltIns.functionN(1)
                                    .typeWith(randomContextBuilderAccessor.irType, newDefault.returnType)
                            )
                        }
                        expression.putValueArgument(randomizersParam.index, newDefaultArg)
                    }

                    newDefault
                }

                if (randomizersLambda != null) {

                    val builder = DeclarationIrBuilder(
                        generatorContext = pluginContext,
                        symbol = randomizersLambda.symbol,
                    )

                    val newBody = builder.irBlockBody {
                        val blockBodyBuilder = this
                        val randomContextBuilder = randomizersLambda.extensionReceiverParameter.crashOnNull {
                            "at this point, it must be guaranteed that a valid RandomContext is passed to randomizers lambda"
                        }

                        for (typeArg in expression.typeArguments) {

                            /**
                             * Explain the condition of this block:
                             * Randomizers are generated only for:
                             * - type that is not null
                             * - type that is NOT primitives because primitives already have built-in randomizers.
                             */
                            if (typeArg != null && !typeArg.isProvidedPrimitive(typeArg.isNullable())) {
                                /**
                                 * These lambdas are: RandomContext.() -> ClassRandomizer<*>
                                 */
                                val makeRandomizerLambdas = generate_makeClassRandomizer_Lambdas(
                                    randomizersLambda = randomizersLambda,
                                    randomType = typeArg,
                                    // typeParamOfRandomFunction = randomFunction.typeParameters,
                                    randomFunctionMetaData= RandomFunctionMetaData.make(
                                        randomFunctionTypes = randomFunction.typeParameters,
                                        classTypes = run {
                                            val companionObjOfRandomFunction = (randomFunction.parent as? IrClass).crashOnNull {
                                                developerErrorMsg("Random function must be declared inside a valid companion object")
                                            }
                                            val classParamList = (companionObjOfRandomFunction.parent as? IrClass)?.typeParameters.crashOnNull {
                                                developerErrorMsg("Random function must be declared inside a valid companion object that is within a valid class")
                                            }
                                            classParamList
                                        },
                                    ),
                                )


                                /**
                                 * This call "addForTier2" function inside "randomizers" lambda
                                 */
                                val addForTier2_FunctionCall = irGet(randomContextBuilder).dotCall(
                                    randomContextBuilderAccessor.addForTier2Call(blockBodyBuilder)
                                ).apply {
                                    putValueArgument(
                                        index = 0, valueArgument = makeIrFunctionExpr(
                                            makeRandomizerLambdas,
                                            pluginContext.irBuiltIns.functionN(1).typeWith(
                                                randomContextAccessor.irType,
                                                makeRandomizerLambdas.returnType,
                                            )
                                        )
                                    )
                                }
                                +addForTier2_FunctionCall
                            }
                        }

                        /**
                         * Appended old body's statements into the end of the new body
                         */
                        randomizersLambda.body?.statements?.forEach { statement ->
                            +statement
                        }
                    }
                    randomizersLambda.body = newBody
                    println("z14: ${newBody.dumpKotlinLike()}")
                }
            }
        }
        val rt = super.visitCall(expression)
        return rt
    }

    /**
     * This build lambdas passed to "addForTier2"
     * These lambdas accept a RandomContext as their extension param, and return a ClassRandomizer<*>
     * Like this:
     *     RandomContext.() -> ClassRandomizer<*>
     */
    private fun generate_makeClassRandomizer_Lambdas(
        randomizersLambda: IrDeclarationParent,
        randomType: IrType,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrSimpleFunction {
        val irSimpleType = (randomType as? IrSimpleType).crashOnNull()

        val rdType = irSimpleType
        val generatedLambda =
            makeLocalLambdaWithoutBody(
                returnType = classRandomizerAccessor.clzz.starProjectedType,
                beforeStandardConfig = {
                    name = Name.special("<generate_makeClassRandomizer_Lambda>")
                }
            ).buildBody { builder ->
                parent = randomizersLambda

                val makeClassRandomizerLambda = this
                makeClassRandomizerLambda.addExtensionReceiver(randomContextAccessor.irType)

                body = builder.irBlockBody {
                    val randomContextParam = makeClassRandomizerLambda.extensionReceiverParameter.crashOnNull()
                    val getRandomContextExpr = irGet(randomContextParam)

                    /**
                     * This lambda is: ()->[randomType]
                     * - generates a random instance of [randomType].
                     * - is passed to "factoryRandomizer" function
                     */
                    val makeRandomInstanceLambda = generate_makeRandom_Lambda(
                        declarationParent = makeClassRandomizerLambda,
                        randomTargetType = rdType,
                        getRandomContextExpr = getRandomContextExpr,
                        randomFunctionMetaData = randomFunctionMetaData,
                    )

                    val classRandomizerMakingCall =
                        classRandomizerUtilAccessor.factoryClassRandomizerFunctionCall(builder).apply {
                            putValueArgument(
                                index = 0, valueArgument = makeIrFunctionExpr(
                                    lambda = makeRandomInstanceLambda,
                                    functionType = pluginContext.irBuiltIns.functionN(0)
                                        .typeWith(makeRandomInstanceLambda.returnType)
                                )
                            )
                            putTypeArgument(0, rdType)
                        }

                    +irReturn(classRandomizerMakingCall)
                }
            }


        return generatedLambda
    }


    /**
     * Generate a lambda like this: ()-> SomeType
     * The lambda is passed to [factoryRandomizer] function, like this: factoryRandomizer(makeRandom = factoryLambda <~ this one)
     * This factoryLambda return a random instance of [randomTargetType]
     */
    private fun generate_makeRandom_Lambda(
        declarationParent: IrDeclarationParent,
        randomTargetType: IrSimpleType,
        randomFunctionMetaData: RandomFunctionMetaData,
        getRandomContextExpr: IrExpression,
    ): IrSimpleFunction {
        val clzz = randomTargetType.classOrNull
        checkNotNull(clzz) {
            "generate_factoryLambda only works with valid class"
        }
        val cl = clzz.owner

        if (cl.isAbstract()) {
            if (!cl.isListAssignable() &&
                !cl.isMap() &&
                !cl.isSet() &&
                !cl.isArrayList() &&
                !cl.isHashSet() &&
                !cl.isLinkedHashSet() &&
                !cl.isHashMap() &&
                !cl.isLinkedHashMap() &&
                !arrayAccessor.isArray(cl)
            ) {
                throw IllegalArgumentException("generate_factoryLambda only works with concrete class")
            }
        }


        val rt = makeLocalLambdaWithoutBody(
            randomTargetType,
            { name = Name.special("<generate_makeRandom_Lambda>") }).apply {
            parent = declarationParent

            val function = this

            val innerBuilder = DeclarationIrBuilder(
                generatorContext = pluginContext,
                symbol = function.symbol,
            )

            /**
             * The new body constructs a random instance of [randomTargetType]
             */
            val newBody = innerBuilder.irBlockBody {
                +irReturn(irBlock {
                    val generateExpr = generateRandomInstanceOfClass(
                        declarationParent = function,
                        receivedTypeArguments = randomTargetType.arguments,
                        irType = randomTargetType,
                        param = null,
                        enclosingClass = null,
                        irClass = clzz.owner,
                        getRandomContextExpr = getRandomContextExpr,
                        getRandomConfigExpr = getRandomContextExpr,
                        builder = innerBuilder,
                        randomFunctionMetaData = randomFunctionMetaData
                    )
                    if (generateExpr != null) {
                        +generateExpr
                    }
                })
            }
            body = newBody
        }

        return rt
    }

    /**
     * complete random() function in [companionObj].
     * This function use the random config in annotation.
     *
     * ```
     *      fun random(
     *          randomizers:RandomContextBuilder.()->Unit = {},
     *      )
     * ```
     */
    private fun completeRandomFunction1(companionObj: IrClass, target: IrClass) {
        val randomFunction = companionObj.findDeclaration<IrSimpleFunction> { function ->
            val con1 = function.name == BaseObjects.randomFunctionName
            val con2 = function.valueParameters.size == 1
            val con3 = function.valueParameters.lastOrNull()?.let { firstParam ->
                firstParam.name == BaseObjects.randomContextBuilderConfigFunctionParamName
            } == true
            con1 && con2 && con3
        }
        if (randomFunction != null) {
            val annotation = target.getAnnotation(BaseObjects.randomizableFqName).crashOnNull {
                developerErrorMsg("At this point, it must be guaranteed that the Randomizable annotation must not null. Cannot run this function on a class that does not have that annotation.")
            }
            val builder = DeclarationIrBuilder(
                generatorContext = pluginContext,
                symbol = randomFunction.symbol,
            )

            val randomFunctionMetaData = RandomFunctionMetaData.make(
                randomFunctionTypes = randomFunction.typeParameters,
                classTypes = target.typeParameters
            )

            val getRandomConfigExpr = makeGetRandomConfigExpressionFromAnnotation(annotation, builder)

            val randomContextBuilderConfigFunctionParam = randomFunction.valueParameters.lastOrNull().crashOnNull {
                developerErrorMsg("randomizers function is missing.")
            }

            randomFunction.body = constructRandomFunctionBody(
                builder = builder,
                randomContextBuilderConfigFunctionParam = randomContextBuilderConfigFunctionParam,
                randomFunction = randomFunction,
                getRandomConfigExpr = getRandomConfigExpr,
                target = target,
                randomFunctionMetaData = randomFunctionMetaData,
            )
            println("z12: ${randomFunction.dumpKotlinLike()}")
        }
    }

    private fun constructRandomFunctionBody(
        builder: DeclarationIrBuilder,
        randomContextBuilderConfigFunctionParam: IrValueParameter,
        randomFunction: IrFunction,
        getRandomConfigExpr: IrExpression,
        target: IrClass,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrBlockBody {
        val randomConfigVar = makeRandomConfigVar(randomFunction, getRandomConfigExpr)
        val getRandomConfigFromVar = builder.irGet(randomConfigVar)

        val randomContextVar = makeRandomContextVar(
            builder = builder,
            randomContextBuilderConfigFunctionParam = randomContextBuilderConfigFunctionParam,
            randomFunction = randomFunction,
            getRandomConfig = getRandomConfigFromVar
        )

        val getRandomContext = builder.irGet(randomContextVar)

        val constructorCall = generateRandomInstanceOfClass(
            declarationParent = randomFunction,
            receivedTypeArguments = emptyList(),
            irType = null,
            irClass = target,
            getRandomContextExpr = getRandomContext,
            getRandomConfigExpr = getRandomConfigFromVar,
            builder = builder,
            param = null,
            enclosingClass = null,
            randomFunctionMetaData = randomFunctionMetaData,
        )
        if (constructorCall != null) {
            return builder.irBlockBody {
                +randomConfigVar
                +randomContextVar
                +builder.irReturn(constructorCall)
            }
        } else {
            throw IllegalArgumentException("unable generate constructor call for $target")
        }
    }

    private fun makeRandomConfigVar(
        randomFunction: IrFunction,
        getRandomConfig: IrExpression,
    ): IrVariable {
        return buildVariable(
            parent = randomFunction,
            startOffset = randomFunction.startOffset,
            endOffset = randomFunction.endOffset,
            origin = IrDeclarationOrigin.DEFINED,
            name = Name.identifier("varRandomConfig"),
            type = randomConfigAccessor.irType
        ).withInit(getRandomConfig)
    }

    /**
     * Create a var that holds the newly created [RandomContext]
     */
    private fun makeRandomContextVar(
        builder: DeclarationIrBuilder,
        randomContextBuilderConfigFunctionParam: IrValueParameter,
        randomFunction: IrFunction,
        getRandomConfig: IrExpression,
    ): IrVariable {

        val block = builder.irBlock(
            resultType = randomizerCollectionAccessor.irType, origin = BaseObjects.Ir.statementOrigin
        ) {

            val randomContextBuilderVar = irTemporary(
                value = randomContextBuilderImpAccessor.constructorFunction(this),
                nameHint = "randomContextBuilder",
                irType = randomContextBuilderAccessor.irType,
            )

            /**
             * Give base random config to builder
             */
            +irGet(randomContextBuilderVar).dotCall(
                randomContextBuilderAccessor.setRandomConfigAndGenerateStandardRandomizersFunction(builder)
            ).withValueArgs(getRandomConfig)

            /**
             * Run config function over a randomizer collection builder
             */
            +makeExprToConfigRandomContextBuilder(
                getRandomContextBuilderExpr = irGet(randomContextBuilderVar),
                randomizerBuilderConfigFunctionAsParam = randomContextBuilderConfigFunctionParam,
                builder = this
            )

            /**
             * Run the randomizer collection builder to get an updated random context.
             * Then store it in a var.
             */
            val updateRandomConfigVar = irTemporary(
                buildRandomContextExpr(
                    builder = this,
                    getRandomContextBuilderExpr = irGet(randomContextBuilderVar),
                ),
                nameHint = "varRandomContext",
            )

            +irGet(updateRandomConfigVar)
        }

        val varRt = buildVariable(
            parent = randomFunction,
            startOffset = randomFunction.startOffset,
            endOffset = randomFunction.endOffset,
            origin = IrDeclarationOrigin.DEFINED,
            name = Name.identifier("varRandomContext"),
            type = randomContextAccessor.irType
        ).withInit(block)

        return varRt
    }

    private fun buildRandomContextExpr(
        builder: IrBuilderWithScope,
        getRandomContextBuilderExpr: IrExpression,
    ): IrExpression {
        return getRandomContextBuilderExpr.dotCall(randomContextBuilderAccessor.buildFunction(builder))
    }

    /**
     * Create an IrExpr to run a config function from [randomizerBuilderConfigFunctionAsParam]  on [RandomContextBuilder] from [getRandomContextBuilderExpr]
     */
    private fun makeExprToConfigRandomContextBuilder(
        getRandomContextBuilderExpr: IrExpression,
        randomizerBuilderConfigFunctionAsParam: IrValueParameter,
        builder: IrBuilderWithScope,
    ): IrExpression {

        val rt =
            builder.irGet(randomizerBuilderConfigFunctionAsParam).dotCall(function1Accessor.invokeFunction(builder))
                .withValueArgs(getRandomContextBuilderExpr)

        return rt
    }

    /**
     * Complete random(randomConfig) function
     */
    private fun completeRandomFunction2(companionObj: IrClass, target: IrClass) {
        val randomFunction = companionObj.findDeclaration<IrSimpleFunction> { function ->
            val con1 = function.name == BaseObjects.randomFunctionName && function.valueParameters.size == 2
            val con2 = function.valueParameters.firstOrNull()?.let { firstParam ->
                firstParam.name == BaseObjects.randomConfigParamName
            } ?: false

            con1 && con2
        }

        if (randomFunction != null) {
            val builder = DeclarationIrBuilder(
                generatorContext = pluginContext,
                symbol = randomFunction.symbol,
            )

            val randomConfigParam =
                randomFunction.valueParameters.firstOrNull { it.name == BaseObjects.randomConfigParamName }
                    .crashOnNull {
                        "random(randomConfig,...) must have first parameter being randomConfig. This is a bug from developer side. "
                    }
            val getBaseRandomConfigExpr = builder.irGet(randomConfigParam)
            val randomFunctionMetaData = RandomFunctionMetaData.make(
                randomFunctionTypes = randomFunction.typeParameters,
                classTypes = target.typeParameters
            )

            val randomContextBuilderConfigFunctionParam = randomFunction.valueParameters.lastOrNull().crashOnNull {
                "randomizers function is missing. This is impossible, and is a bug by developer"
            }
            randomFunction.body = constructRandomFunctionBody(
                builder = builder,
                randomContextBuilderConfigFunctionParam = randomContextBuilderConfigFunctionParam,
                randomFunction = randomFunction,
                getRandomConfigExpr = getBaseRandomConfigExpr,
                target = target,
                randomFunctionMetaData = randomFunctionMetaData,
            )
        }
    }

    /**
     * Create an IR expression that returns a [RandomConfig] instance from [Randomizable] annotation
     */
    private fun makeGetRandomConfigExpressionFromAnnotation(
        annotation: IrConstructorCall, builder: DeclarationIrBuilder
    ): IrExpression {

        val randomConfigArgumentParamData = annotation.getAllArgumentsWithIr().firstOrNull { (irParam, irExpr) ->
            irParam.name == BaseObjects.randomConfigParamName
        }

        val providedArgument = randomConfigArgumentParamData?.second

        if (providedArgument != null) {

            val providedArgumentClassSymbol = (providedArgument as? IrClassReference)?.classType?.classOrNull
                .crashOnNull {
                    "$providedArgument must be a KClass"
                }

            val providedClassIsDefaultRandomConfigClass =
                providedArgumentClassSymbol.owner.classId == BaseObjects.DefaultRandomConfig_ClassId

            if (providedClassIsDefaultRandomConfigClass) {
                return getDefaultRandomConfigInstance(builder)
            } else {
                val providedArgumentIrClass = providedArgumentClassSymbol.owner

                if (providedArgumentIrClass.isObject) {
                    return builder.irGetObject(providedArgumentClassSymbol)
                } else if (providedArgumentIrClass.isClass) {

                    when (providedArgumentIrClass.modality) {
                        ABSTRACT, SEALED -> {
                            throw IllegalArgumentException("${providedArgumentIrClass.name} must not be abstract")
                        }

                        OPEN, FINAL -> {

                            /**
                             * There's a custom [RandomConfig] class, proceed to create an instance of it.
                             * Constructor must be zero-arg in case that is a class, otherwise throw exception
                             */

                            val primaryConstructor = providedArgumentIrClass.primaryConstructor.takeIf {
                                it != null && it.valueParameters.isEmpty()
                            }

                            val constructor = primaryConstructor ?: providedArgumentIrClass.constructors.firstOrNull {
                                it.valueParameters.isEmpty()
                            }

                            if (constructor != null) {
                                return builder.irCall(constructor)
                            } else {
                                throw IllegalArgumentException("${providedArgumentIrClass.name}: must have a zero-arg constructor")
                            }
                        }
                    }

                } else {
                    throw IllegalArgumentException("${providedArgumentIrClass.name} must either be a class or an object")
                }
            }
        } else {
            val randomConfigParam: IrValueParameter? = randomConfigArgumentParamData?.first
            require(randomConfigParam?.hasDefaultValue() == true) {
                "impossible, a default class or object must be provided for @Randomizable, this is a mistake by the developer"
            }
            return getDefaultRandomConfigInstance(builder)
        }
    }

    /**
     * Construct an IrCall to access [RandomConfigImp.Companion.default]
     */
    private fun getDefaultRandomConfigInstance(builder: DeclarationIrBuilder): IrCall {
        return builder.irGetObject(defaultRandomConfigAccessor.defaultRandomConfigCompanionObject.symbol)
            .dotCall(builder.irCall(defaultRandomConfigAccessor.getDefaultRandomConfigInstance))
    }

    /**
     * Generate an [IrExpression] that can return a random instance of [irClass]
     */
    private fun generateRandomInstanceOfClass(
        /**
         * Declaration parent for generated lambda downstream
         */
        declarationParent: IrDeclarationParent?,
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * Param that hold the instance returned by this function
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irType: IrType?,
        irClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        if (irClass.isInner) {
            throw IllegalArgumentException("Inner class is not supported for now.")
        }

        val rt = stopAtFirstNotNull({ generateRandomObj(irClass, builder) },
            { generateRandomEnum(irClass, getRandomContextExpr, builder) },
            {
                generateRandomConcreteClass(
                    declarationParent = declarationParent,
                    receivedTypeArgument = receivedTypeArguments,
                    param = param,
                    enclosingClass = enclosingClass,
                    irType = irType,
                    irClass = irClass,
                    getRandomContextExpr = getRandomContextExpr,
                    getRandomConfigExpr = getRandomConfigExpr,
                    builder = builder,
                    randomFunctionMetaData=randomFunctionMetaData,
                )
            },
            {
                generateStdCollection(
                    declarationParent = declarationParent,
                    receivedTypeArguments = receivedTypeArguments,
                    param = param,
                    enclosingClass = enclosingClass,
                    irType = irType,
                    collectionIrClass = irClass,
                    getRandomContextExpr = getRandomContextExpr,
                    getRandomConfigExpr = getRandomConfigExpr,
                    builder = builder,
                    randomFunctionMetaData=randomFunctionMetaData,
                )
            },
            {
                generateRandomSealClass(
                    irClass = irClass,
                    getRandomContextExpr = getRandomContextExpr,
                    builder = builder,
                    randomFunctionMetaData = randomFunctionMetaData
                )
            },
            {
                generateRandomAbstractClass(
                    irClass = irClass,
                    getRandomContextExpr = getRandomContextExpr,
                    builder = builder,
                    randomFunctionMetaData = randomFunctionMetaData
                )
            })
        return rt
    }

    private fun generateStdCollection(
        declarationParent: IrDeclarationParent?,
        receivedTypeArguments: List<IrTypeArgument>?,
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irType: IrType?,
        collectionIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        val rt = stopAtFirstNotNull(
            {
                generateArray(
                    declarationParent = declarationParent,
                    receivedTypeArguments = receivedTypeArguments,
                    param = param,
                    enclosingClass = enclosingClass,
                    arrayIrClass = collectionIrClass,
                    irListType = irType,
                    getRandomContextExpr = getRandomContextExpr,
                    getRandomConfigExpr = getRandomConfigExpr,
                    builder = builder,
                    randomFunctionMetaData=randomFunctionMetaData,
                )
            },
            {
                generateArrayList(
                    declarationParent = declarationParent,
                    receivedTypeArguments = receivedTypeArguments,
                    param = param,
                    enclosingClass = enclosingClass,
                    listIrClass = collectionIrClass,
                    irListType = irType,
                    getRandomContextExpr = getRandomContextExpr,
                    getRandomConfigExpr = getRandomConfigExpr,
                    builder = builder,
                    randomFunctionMetaData=randomFunctionMetaData,
                )
            },
            {
                generateHashMap(
                    declarationParent = declarationParent,
                    receivedTypeArguments = receivedTypeArguments,
                    param = param,
                    enclosingClass = enclosingClass,
                    mapIrClass = collectionIrClass,
                    irMapType = irType,
                    getRandomContextExpr = getRandomContextExpr,
                    getRandomConfigExpr = getRandomConfigExpr,
                    builder = builder,
                    randomFunctionMetaData=randomFunctionMetaData,
                )
            },
            {
                generateLinkedHashMap(
                    declarationParent = declarationParent,
                    receivedTypeArguments = receivedTypeArguments,
                    param = param,
                    enclosingClass = enclosingClass,
                    mapIrClass = collectionIrClass,
                    irMapType = irType,
                    getRandomContextExpr = getRandomContextExpr,
                    getRandomConfigExpr = getRandomConfigExpr,
                    builder = builder,
                    randomFunctionMetaData=randomFunctionMetaData,
                )
            },
            {
                generateMap(
                    declarationParent = declarationParent,
                    receivedTypeArguments = receivedTypeArguments,
                    param = param,
                    enclosingClass = enclosingClass,
                    mapIrClass = collectionIrClass,
                    irMapType = irType,
                    getRandomContextExpr = getRandomContextExpr,
                    getRandomConfigExpr = getRandomConfigExpr,
                    builder = builder,
                    randomFunctionMetaData = randomFunctionMetaData,
                )
            }, {
                generateList(
                    declarationParent = declarationParent,
                    receivedTypeArguments = receivedTypeArguments,
                    param = param,
                    enclosingClass = enclosingClass,
                    listIrClass = collectionIrClass,
                    irListType = irType,
                    getRandomContextExpr = getRandomContextExpr,
                    getRandomConfigExpr = getRandomConfigExpr,
                    builder = builder,
                    randomFunctionMetaData = randomFunctionMetaData,
                )
            },
            {
                generateHashSet(
                    declarationParent = declarationParent,
                    receivedTypeArguments = receivedTypeArguments,
                    param = param,
                    enclosingClass = enclosingClass,
                    setIrClass = collectionIrClass,
                    irListType = irType,
                    getRandomContextExpr = getRandomContextExpr,
                    getRandomConfigExpr = getRandomConfigExpr,
                    builder = builder,
                    randomFunctionMetaData=randomFunctionMetaData,
                )
            },
            {
                generateLinkedHashSet(
                    declarationParent = declarationParent,
                    receivedTypeArguments = receivedTypeArguments,
                    param = param,
                    enclosingClass = enclosingClass,
                    setIrClass = collectionIrClass,
                    irListType = irType,
                    getRandomContextExpr = getRandomContextExpr,
                    getRandomConfigExpr = getRandomConfigExpr,
                    builder = builder,
                    randomFunctionMetaData=randomFunctionMetaData,
                )
            },
            {
                generateSet(
                    declarationParent = declarationParent,
                    receivedTypeArguments = receivedTypeArguments,
                    param = param,
                    enclosingClass = enclosingClass,
                    setIrClass = collectionIrClass,
                    irListType = irType,
                    getRandomContextExpr = getRandomContextExpr,
                    getRandomConfigExpr = getRandomConfigExpr,
                    builder = builder,
                    randomFunctionMetaData=randomFunctionMetaData,
                )
            }

        )
        return rt
    }

    /**
     * Generate an expression that will invoke List{} function to create a list of random size, holding random elements.
     */
    private fun generateArrayList(
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the list
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irListType: IrType?,
        listIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        return templateGenerateListDerivative(
            classCheck = { listIrClass.isArrayList() },
            factoryFunctionCall = listAccessor.makeArrayList(builder),
            declarationParent = declarationParent,
            receivedTypeArguments = receivedTypeArguments,
            param = param,
            enclosingClass = enclosingClass,
            irListType = irListType,
            listIrClass = listIrClass,
            getRandomContextExpr = getRandomContextExpr,
            getRandomConfigExpr = getRandomConfigExpr,
            builder = builder,
            randomFunctionMetaData=randomFunctionMetaData,
        )
    }

    private fun generateArray(
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the list
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irListType: IrType?,
        arrayIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        return templateGenerateListDerivative(
            classCheck = { arrayAccessor.isArray(arrayIrClass) },
            factoryFunctionCall = arrayAccessor.makeArray(builder),
            declarationParent = declarationParent,
            receivedTypeArguments = receivedTypeArguments,
            param = param,
            enclosingClass = enclosingClass,
            irListType = irListType,
            listIrClass = arrayIrClass,
            getRandomContextExpr = getRandomContextExpr,
            getRandomConfigExpr = getRandomConfigExpr,
            builder = builder,
            randomFunctionMetaData=randomFunctionMetaData,
        )
    }

    /**
     * A template to generate collection derived from [List]
     */
    private fun templateGenerateListDerivative(
        classCheck: () -> Boolean,
        factoryFunctionCall: IrCall,
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the list
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irListType: IrType?,
        listIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        if (!classCheck()) {
            return null
        }

        val elementTypes = extractTypeArgument(
            receivedTypeArgument = receivedTypeArguments, irType = irListType
        ).firstOrNull()

        if (elementTypes != null) {
            val listExpr = generateList(
                declarationParent = declarationParent,
                receivedTypeArguments = receivedTypeArguments,
                param = param,
                enclosingClass = enclosingClass,
                irListType = irListType,
                listIrClass = listAccessor.clzz.owner,
                getRandomContextExpr = getRandomContextExpr,
                getRandomConfigExpr = getRandomConfigExpr,
                builder = builder,
                randomFunctionMetaData = randomFunctionMetaData,
            )
            if (listExpr != null) {
                val tt = elementTypes.typeOrNull.crashOnNull {
                    val paramNamePrefix = param?.let { "${param.name}:" } ?: ""
                    "$paramNamePrefix Set's element type must be specified. It is null here."
                }
                return factoryFunctionCall
                    .withTypeArgs(tt)
                    .withValueArgs(listExpr)
            } else {
                return null
            }
        } else {
            return null
        }
    }

    /**
     * Generate an expression that will invoke List{} function to create a list of random size, holding random elements.
     */
    private fun generateList(
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the list
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irListType: IrType?,
        listIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {


        if (!listIrClass.isListAssignable()) {
            return null
        }

        val elementTypes = extractTypeArgument(
            receivedTypeArgument = receivedTypeArguments, irType = irListType
        ).firstOrNull()

        if (elementTypes != null) {
            val type = elementTypes.typeOrNull.crashOnNull {
                val paramNamePrefix = param?.let { "${param.name}:" } ?: ""
                "$paramNamePrefix List's element type must be specified. It is null here."
            }

            val randomElementLambdaExpr = run {

                /**
                 * This block generates the lambda that will be passed to makeList() function
                 */

                val lambdaDeclaration = makeLocalLambdaWithoutBody(type, {
                    name = Name.special("<generateList_withinRandomFunction>")
                }).apply {
                    val lambdaFunction = this

                    declarationParent?.also { parent = it }

                    addValueParameter("index", pluginContext.irBuiltIns.intType)

                    val lambdaBuilder = DeclarationIrBuilder(
                        generatorContext = pluginContext,
                        symbol = this.symbol,
                    )
                    val randomElementExpr = generateRandomType(
                        declarationParent = lambdaFunction,
                        param = null,
                        enclosingClass = null,
                        receivedTypeArgument = null,
                        targetType = type,
                        builder = builder,
                        getRandomContextExpr = getRandomContextExpr,
                        getRandomConfigExpr = getRandomConfigExpr,
                        randomFunctionMetaData = randomFunctionMetaData,
                        optionalParamMetaDataForReporting = ListReportData(
                            valueType = type.dumpKotlinLike(),
                            paramName = param?.name?.asString(),
                            enclosingClassName = enclosingClass?.name?.asString(),
                        )
                    )
                    body = lambdaBuilder.irBlockBody {
                        +irReturn(randomElementExpr)
                    }
                }

                makeIrFunctionExpr(
                    lambda = lambdaDeclaration,
                    functionType = pluginContext.irBuiltIns.functionN(1)
                        .typeWith(pluginContext.irBuiltIns.intType, type)
                )
            }

            val sizeExpr = getRandomConfigExpr.dotCall(
                randomConfigAccessor.randomCollectionSize(builder)
            )

            val rt = listAccessor.makeList(builder)
                .withValueArgs(sizeExpr, randomElementLambdaExpr)
                .withTypeArgs(type)

            return rt

        } else {
            return null
        }
    }


    /**
     * Generate an expression that can generate a random Map
     */
    private fun generateMap(
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the map
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irMapType: IrType?,
        mapIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        if (!mapIrClass.isMap()) {
            return null
        }

        // get element type
        val elementTypes = extractTypeArgument(
            receivedTypeArgument = receivedTypeArguments, irType = irMapType
        ).take(2)

        if (elementTypes.size == 2) {
            val keyTypeArg = elementTypes[0]
            val valueTypeArg = elementTypes[1]

            /**
             * Generate an expr that do something like this:
             * makeMap(size, pairFactoryFunction)
             */
            val sizeExpr = getRandomConfigExpr.dotCall(
                randomConfigAccessor.randomCollectionSize(builder)
            )

            val keyType = keyTypeArg.typeOrNull.crashOnNull {
                "Key type passed to makeMap() must not be null. This is a bug."
            }

            val makeKeyLambdaExpr: IrExpression = run {
                val lambda = makeLocalLambdaWithoutBody(keyType).buildBody { keyLambdaBuilder ->
                    declarationParent?.let { parent = it }
                    val keyLambda = this
                    body = keyLambdaBuilder.irBlockBody {
                        // call something to return a random key
                        val randomKey = generateRandomType(
                            declarationParent = keyLambda,
                            param = null,
                            enclosingClass = enclosingClass,
                            receivedTypeArgument = null,
                            targetType = keyType,
                            builder = keyLambdaBuilder,
                            getRandomContextExpr = getRandomContextExpr,
                            getRandomConfigExpr = getRandomConfigExpr,
                            randomFunctionMetaData = randomFunctionMetaData,
                            optionalParamMetaDataForReporting = MapKeyReportData(
                                keyType = keyType.dumpKotlinLike(),
                                paramName = param?.name?.asString(),
                                enclosingClassName = enclosingClass?.name?.asString(),
                            )
                        )
                        +keyLambdaBuilder.irReturn(randomKey)
                    }
                }
                makeIrFunctionExpr(
                    lambda = lambda,
                    functionType = pluginContext.irBuiltIns.functionN(0).typeWith(keyType),
                )
            }

            val valueType = valueTypeArg.typeOrNull.crashOnNull {
                "Value type passed to makeMap() must not be null. This is a bug."
            }
            val makeValueLambda: IrExpression = run {
                val valueLambda = makeLocalLambdaWithoutBody(valueType).buildBody { valueLambdaBuilder ->
                    declarationParent?.let { parent = it }
                    val valueLambda = this
                    body = valueLambdaBuilder.irBlockBody {
                        // call something to return a random value
                        val randomValue = generateRandomType(
                            declarationParent = valueLambda,
                            param = null,
                            enclosingClass = enclosingClass,
                            receivedTypeArgument = null,
                            targetType = valueType,
                            builder = valueLambdaBuilder,
                            getRandomContextExpr = getRandomContextExpr,
                            getRandomConfigExpr = getRandomConfigExpr,
                            randomFunctionMetaData = randomFunctionMetaData,
                            optionalParamMetaDataForReporting = MapValueReportData(
                                valueType = valueType.dumpKotlinLike(),
                                paramName = param?.name?.asString(),
                                enclosingClassName = enclosingClass?.name?.asString(),
                            )
                        )
                        +valueLambdaBuilder.irReturn(randomValue)
                    }
                }
                makeIrFunctionExpr(
                    lambda = valueLambda,
                    functionType = pluginContext.irBuiltIns.functionN(0).typeWith(valueType),
                )
            }

            val makeMapFunctionCall = mapAccessor.makeMapFunction(builder)
                .withValueArgs(sizeExpr, makeKeyLambdaExpr, makeValueLambda)
                .withTypeArgs(keyType, valueType)

            return makeMapFunctionCall
        } else {
            return null
        }
    }


    private fun generateHashMap(
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the map
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irMapType: IrType?,
        mapIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        val rt = templateToGenerateMap(
            isMapCheck = { mapIrClass.isHashMap() },
            makeMapFunctionCall = mapAccessor.makeHashMap(builder),
            declarationParent = declarationParent,
            receivedTypeArguments = receivedTypeArguments,
            param = param,
            enclosingClass = enclosingClass,
            irMapType = irMapType,
            mapIrClass = mapIrClass,
            getRandomContextExpr = getRandomContextExpr,
            getRandomConfigExpr = getRandomConfigExpr,
            builder = builder,
            randomFunctionMetaData=randomFunctionMetaData,
        )
        return rt
    }

    private fun generateLinkedHashMap(
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the map
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irMapType: IrType?,
        mapIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        return templateToGenerateMap(
            isMapCheck = { mapIrClass.isLinkedHashMap() },
            makeMapFunctionCall = mapAccessor.makeLinkedHashMap(builder),
            declarationParent = declarationParent,
            receivedTypeArguments = receivedTypeArguments,
            param = param,
            enclosingClass = enclosingClass,
            irMapType = irMapType,
            mapIrClass = mapIrClass,
            getRandomContextExpr = getRandomContextExpr,
            getRandomConfigExpr = getRandomConfigExpr,
            builder = builder,
            randomFunctionMetaData=randomFunctionMetaData,
        )
    }


    private fun templateToGenerateMap(
        isMapCheck: () -> Boolean,
        makeMapFunctionCall: IrCall,
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the map
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irMapType: IrType?,
        mapIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        if (!isMapCheck()) {
            return null
        }
        val mapExpr = generateMap(
            declarationParent = declarationParent,
            receivedTypeArguments = receivedTypeArguments,
            param = param,
            enclosingClass = enclosingClass,
            irMapType = irMapType,
            mapIrClass = mapAccessor.clzz.owner,
            getRandomContextExpr = getRandomContextExpr,
            getRandomConfigExpr = getRandomConfigExpr,
            builder = builder,
            randomFunctionMetaData=randomFunctionMetaData,
        )
        if (mapExpr != null) {
            val elementTypes = extractTypeArgument(
                receivedTypeArgument = receivedTypeArguments, irType = irMapType
            ).take(2)
            val keyTypeArg = elementTypes[0]
            val valueTypeArg = elementTypes[1]
            return makeMapFunctionCall
                .withTypeArgs(keyTypeArg.typeOrFail, valueTypeArg.typeOrFail)
                .withValueArgs(mapExpr)
        } else {
            return null
        }
    }


    private fun generateSet(
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the list
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irListType: IrType?,
        setIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        return templateToGenerateSet(
            setCheck = { setIrClass.isSet() },
            listToSetFunctionCall = { setAccessor.listToSet(builder) },
            declarationParent = declarationParent,
            receivedTypeArguments = receivedTypeArguments,
            param = param,
            enclosingClass = enclosingClass,
            irListType = irListType,
            setIrClass = setIrClass,
            getRandomContextExpr = getRandomContextExpr,
            getRandomConfigExpr = getRandomConfigExpr,
            builder = builder,
            randomFunctionMetaData=randomFunctionMetaData,
        )
    }

    private fun generateHashSet(
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the list
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irListType: IrType?,
        setIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        return templateToGenerateSet(
            setCheck = { setIrClass.isHashSet() },
            listToSetFunctionCall = { setAccessor.makeHashSet(builder) },
            declarationParent = declarationParent,
            receivedTypeArguments = receivedTypeArguments,
            param = param,
            enclosingClass = enclosingClass,
            irListType = irListType,
            setIrClass = setIrClass,
            getRandomContextExpr = getRandomContextExpr,
            getRandomConfigExpr = getRandomConfigExpr,
            builder = builder,
            randomFunctionMetaData=randomFunctionMetaData,
        )
    }

    private fun generateLinkedHashSet(
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the list
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irListType: IrType?,
        setIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        return templateToGenerateSet(
            setCheck = { setIrClass.isLinkedHashSet() },
            listToSetFunctionCall = { setAccessor.makeLinkedHashSet(builder) },
            declarationParent = declarationParent,
            receivedTypeArguments = receivedTypeArguments,
            param = param,
            enclosingClass = enclosingClass,
            irListType = irListType,
            setIrClass = setIrClass,
            getRandomContextExpr = getRandomContextExpr,
            getRandomConfigExpr = getRandomConfigExpr,
            builder = builder,
            randomFunctionMetaData=randomFunctionMetaData,
        )
    }


    private fun templateToGenerateSet(
        setCheck: () -> Boolean,
        listToSetFunctionCall: () -> IrCall,
        declarationParent: IrDeclarationParent?,
        /**
         * Typed received externally
         */
        receivedTypeArguments: List<IrTypeArgument>?,
        /**
         * The param that holds the list
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        irListType: IrType?,
        setIrClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        if (!setCheck()) {
            return null
        }

        val elementTypeArg = extractTypeArgument(
            receivedTypeArgument = receivedTypeArguments, irType = irListType
        ).firstOrNull()

        if (elementTypeArg != null) {

            val elementType = elementTypeArg.typeOrNull.crashOnNull {
                val paramNamePrefix = param?.let { "${param.name}:" } ?: ""
                "$paramNamePrefix Set's element type must be specified. It is null here."
            }

            val listExpr = generateList(
                declarationParent = declarationParent,
                receivedTypeArguments = receivedTypeArguments,
                param = param,
                enclosingClass = enclosingClass,
                irListType = irListType,
                listIrClass = listAccessor.clzz.owner,
                getRandomContextExpr = getRandomContextExpr,
                getRandomConfigExpr = getRandomConfigExpr,
                builder = builder,
                randomFunctionMetaData = randomFunctionMetaData,
            )
            if (listExpr != null) {
                return listToSetFunctionCall()
                    .withTypeArgs(elementType)
                    .withValueArgs(listExpr)
            } else {
                return null
            }
        } else {
            return null
        }
    }


    private fun generateRandomObj(
        irClass: IrClass,
        builder: DeclarationIrBuilder,
    ): IrExpression? {
        if (irClass.isObject) {
            return builder.irGetObject(irClass.symbol)
        } else {
            return null
        }
    }

    private fun generateRandomEnum(
        irClass: IrClass,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
    ): IrExpression? {
        if (irClass.isEnumClass) {
            val getRandom = getRandomConfigExpr.dotCall(randomConfigAccessor.random(builder))
            if (irClass.hasEnumEntries) {
                // make an IR to access "entries"
                val irEntriesFunction = run {
                    val irEntries = irClass.declarations.firstOrNull {
                        it.getNameWithAssert().toString() == "entries"
                    } as? IrProperty
                    irEntries?.getter.crashOnNull {
                        "enum ${irClass.name} does not have \"entries\" field"
                    }
                }

                // then call randomFunction on "entries" accessor ir
                val rt = builder.irCall(irEntriesFunction)
                    .extensionDotCall(builder.irCall(randomAccessor.randomFunctionOnCollectionOneArg))
                    .withValueArgs(getRandom)

                return rt
            } else {
                val irValues =
                    irClass.declarations.firstOrNull { it.getNameWithAssert().toString() == "values" } as? IrFunction

                if (irValues != null) {
                    val randomFunction = randomAccessor.randomFunctionOnArrayOneArg
                    val rt = builder.irCall(irValues).extensionDotCall(builder.irCall(randomFunction))
                        .withValueArgs(getRandom)
                    return rt
                }
            }

            throw IllegalArgumentException("Impossible - Enum ${irClass.name} does not have entries or values()")

        } else {
            return null
        }
    }

    /**
     * Concrete class is final or open class that is:
     * - not abstract
     * - not enum
     * - not object
     */
    private fun generateRandomConcreteClass(
        declarationParent: IrDeclarationParent?,
        receivedTypeArgument: List<IrTypeArgument>?,
        /**
         * this param is the one to hold an instance of [irClass]
         */
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        /**
         * type of [param]
         */
        irType: IrType?,
        irClass: IrClass,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        if (irClass.isArrayList() ||
            irClass.isHashSet() ||
            irClass.isLinkedHashSet() ||
            irClass.isHashMap() ||
            irClass.isLinkedHashMap() ||
            arrayAccessor.isArray(irClass)
        ) {
            return null
        }
        if (irClass.isFinalOrOpenConcrete() && !irClass.isObject && !irClass.isEnumClass) {

            val randomPrimitiveExpr = generateRandomPrimitive(
                type = irType ?: irClass.defaultType,
                builder = builder,
                getRandomContext = getRandomContextExpr,
                getRandomConfigExpr = getRandomConfigExpr,
            )

            if (randomPrimitiveExpr != null) {
                return randomPrimitiveExpr
            }

            val constructor = getConstructor(irClass)
            if (constructor != null) {
                val typeArgumentList: List<IrTypeArgument> = extractTypeArgument(
                    receivedTypeArgument = receivedTypeArgument, irType = irType
                )

                val paramExpressions = constructor.valueParameters.withIndex().map { (_, _param) ->
                    val typeIndex = (_param.type.classifierOrNull as? IrTypeParameterSymbol)?.owner?.index
                    val receivedTypeArg = typeIndex?.let { typeArgumentList.getOrNull(it) }
                    generateRandomParam(
                        declarationParent = declarationParent,
                        receivedTypeArgument = receivedTypeArg,
                        paramFromConstructor = _param,
                        enclosingClass = irClass,
                        builder = builder,
                        getRandomContextExpr = getRandomContextExpr,
                        getRandomConfigExpr = getRandomConfigExpr,
                        randomFunctionMetaData=randomFunctionMetaData,
                    )
                }

                val constructorCall = builder.irCallConstructor(
                    callee = constructor.symbol, typeArguments = emptyList()
                ).withValueArgs(paramExpressions)
                return constructorCall
            } else {
                return throwUnableToRandomizeException(
                    builder, "${irClass.name} does not have a usable constructor"
                )
            }
        } else {
            return null
        }
    }

    /**
     * Extract concrete type from provided generic type argument from various sources.
     */
    private fun extractTypeArgument(
        /**
         * Explicit provided type, highest priority
         */
        receivedTypeArgument: List<IrTypeArgument>?,
        /**
         * just some IrType object that may contains type information in its argument
         */
        irType: IrType?,
    ): List<IrTypeArgument> {
        val rt: List<IrTypeArgument> = stopAtFirstNotNull(
            { receivedTypeArgument },
            { (irType as? IrSimpleType)?.arguments },
        ) ?: emptyList()
        return rt
    }

    private fun ifNotNullElse(
        type: IrType,
        candidate: IrExpression,
        onCandidateNotNull: IrExpression,
        onCandidateNull: IrExpression,
        builder: DeclarationIrBuilder,
    ): IrExpression {
        return builder.irIfNull(type, candidate, onCandidateNull, onCandidateNotNull)
    }

    /**
     * Construct an if-else expression using `RandomConfig.nextBool` as condition. Like this
     * ```
     * if(randomConfig.nextBool()){
     *    [randomPart]
     * }else{
     *    null << always return null on else
     * }
     * ```
     */
    private fun randomOrNull(
        builder: DeclarationIrBuilder,
        /**
         * An expr to get a [RandomConfig]
         */
        getRandomContext: IrExpression,
        /**
         * this is the return type of the if-else expr
         */
        type: IrType,
        randomPart: IrExpression,
    ): IrExpression {
        return randomIfElse(
            builder = builder,
            getRandomContextExpr = getRandomContext,
            type = type,
            truePart = randomPart,
            elsePart = builder.irNull()
        )
    }

    /**
     * Construct an if-else expression using `RandomConfig.nextBool` as condition. Like this
     * ```
     * if(randomConfig.nextBool()){
     *    [truePart]
     * }else{
     *    [elsePart]
     * }
     * ```
     */
    private fun randomIfElse(
        builder: DeclarationIrBuilder,
        /**
         * An expr to get a [RandomConfig]
         */
        getRandomContextExpr: IrExpression,
        /**
         * this is the return type of the if-else expr
         */
        type: IrType, truePart: IrExpression, elsePart: IrExpression
    ): IrExpression {
        val conditionExpr = getRandomContextExpr.dotCall(randomConfigAccessor.nextBoolean(builder))
        return builder.irIfThenElse(
            type = type, condition = conditionExpr, thenPart = truePart, elsePart = elsePart
        )
    }

    private fun generateRandomSealClass(
        irClass: IrClass,
        getRandomContextExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        if (irClass.isSealed()) {
            TODO()
        } else {
            return null
        }
    }

    private fun generateRandomAbstractClass(
        irClass: IrClass,
        getRandomContextExpr: IrExpression,
        builder: DeclarationIrBuilder,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression? {
        if (irClass.isAbstract() && !irClass.isSealed() && irClass.isAnnotatedWithRandomizable()) {
            TODO("not supported yet")
        } else {
            return null
        }
    }


    private fun generateRandomParam(
        declarationParent: IrDeclarationParent?,
        /**
         * Received type argument is generic type information passed down from higher level to the param represented by [paramFromConstructor].
         */
        receivedTypeArgument: IrTypeArgument?,
        /**
         * parameter directly from a constructor.
         * In case of generic param, this object only contains the direct generic type from its constructor.
         * If there's a [receivedTypeArgument], then [receivedTypeArgument] it must be prioritized over this, because this one does not contain enough information to construct the correct call.
         */
        paramFromConstructor: IrValueParameter,
        enclosingClass: IrClass,
        builder: DeclarationIrBuilder,
        /**
         * An expression that return a [RandomContext]
         */
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression {
        val paramType = paramFromConstructor.type as? IrSimpleTypeImpl
        val paramTypeWithTypeReplacement = replaceTypeArgument(paramType!!, randomFunctionMetaData.randomFunctionTypeList)
        return generateRandomType(
            declarationParent = declarationParent,
            enclosingClass = enclosingClass,
            param = paramFromConstructor,
            receivedTypeArgument = receivedTypeArgument,
            targetType = paramTypeWithTypeReplacement,
            builder = builder,
            getRandomContextExpr = getRandomContextExpr,
            getRandomConfigExpr = getRandomConfigExpr,
            optionalParamMetaDataForReporting = ParamReportData.fromIrElements(
                paramFromConstructor, paramTypeWithTypeReplacement, enclosingClass
            ),
            randomFunctionMetaData = randomFunctionMetaData,
        )
    }

    /**
     * Replace generic type of [irType] with generic type from random() function.
     * The typed is mapped using their index.
     * List<List<T>> -> List<List<T_R>>
     */
    private fun replaceTypeArgument(
        irType: IrSimpleType,
        typeParamListOfRandomFunction: List<IrTypeParameter>,
    ): IrSimpleType {
        val newArg = irType.arguments.map { arg ->

            val argType = arg.typeOrNull
            val argClassifier = argType?.classifierOrNull

            val newArg: IrTypeArgument = when (argClassifier) {
                is IrClassSymbol -> {
                    val spType = argType as? IrSimpleType
                    if (spType != null) {
                        replaceTypeArgument(argType, typeParamListOfRandomFunction)
                    } else {
                        arg
                    }
                }

                is IrTypeParameterSymbol -> {
                    val typeIndex = argClassifier.owner.index
                    val typeFromRandomFunction = typeParamListOfRandomFunction.getOrNull(typeIndex)
                    val argSimpleType = (arg as? IrSimpleType)
                    if (argSimpleType != null && typeFromRandomFunction != null) {
                        val alteredArg = IrSimpleTypeImpl(
                            kotlinType = arg.originalKotlinType,
                            classifier = typeFromRandomFunction.symbol,
                            nullability = arg.nullability,
                            arguments = argSimpleType.arguments,
                            annotations = arg.annotations,
                            abbreviation = arg.abbreviation
                        )
                        alteredArg
                    } else {
                        arg
                    }
                }

                else -> arg
            }
            newArg
        }
        val rt = IrSimpleTypeImpl(
            kotlinType = irType.originalKotlinType,
            classifier = irType.classifier,
            nullability = irType.nullability,
            arguments = newArg,
            annotations = irType.annotations,
            abbreviation = irType.abbreviation
        )
        return rt
    }

    private fun generateRandomType(
        declarationParent: IrDeclarationParent?,
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        /**
         * Received type argument is generic type information passed down from higher level or wherever.
         * This can be used to look-up type (could be concrete or intermediate generic) for [targetType].
         */
        receivedTypeArgument: IrTypeArgument?,
        targetType: IrType,
        builder: DeclarationIrBuilder,
        /**
         * An expression that return a [RandomContext]
         */
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        /**
         * This optional object is for generating error reporting expression.
         * If given, a more descriptive message can be generated, otherwise, the message will be based on [targetType]
         */
        optionalParamMetaDataForReporting: ReportData,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression {
        val primitive = generateRandomPrimitive(
            type = targetType,
            builder = builder,
            getRandomContext = getRandomContextExpr,
            getRandomConfigExpr = getRandomConfigExpr,
        )

        if (primitive != null) {
            return primitive
        }

        val typeSymbol = targetType.classifierOrNull as? IrTypeParameterSymbol
        val receivedType = receivedTypeArgument as? IrSimpleType
        val receivedTypeClassifier = receivedType?.classifierOrNull

        val receiveTypeIsGeneric = receivedTypeClassifier !is IrClassSymbol


        if (targetType.isTypeParameter() && typeSymbol != null && (receivedTypeArgument == null || receiveTypeIsGeneric)) {
            /**
             * This is the case in which param type is generic, but does not receive any concrete type from the outside.
             * This construct ane expr that passes the generic from random() function to [RandomContext] to get a random instance.
             */
            return generateRandomTypeForTypelessGeneric(
                receivedTypeClassifier = receivedTypeClassifier,
                param = param,
                enclosingClass = enclosingClass,
                typeSymbol = typeSymbol,
                randomFunctionMetaData = randomFunctionMetaData,
                targetType = targetType,
                builder = builder,
                getRandomContextExpr = getRandomContextExpr,
                optionalParamMetaDataForReporting = optionalParamMetaDataForReporting,
            )
        } else {
            /**
             * This is the case in which it is possible to retrieve a concrete/define class for the generic type.
             */
            return generateRandomTypeWithDefinedType(
                param = param,
                enclosingClass = enclosingClass,
                declarationParent = declarationParent,
                receivedType = receivedType,
                targetType = targetType,
                builder = builder,
                getRandomContextExpr = getRandomContextExpr,
                getRandomConfigExpr = getRandomConfigExpr,
                optionalParamMetaDataForReporting = optionalParamMetaDataForReporting,
                randomFunctionMetaData = randomFunctionMetaData,
            )
        }
    }

    /**
     * This is the case in which it is possible to retrieve a concrete/define class for the generic type.
     */
    private fun generateRandomTypeWithDefinedType(
        /**
         * Declaration parent is for generating lambda down the line. For now, it is only for the lambda passed to List() function
         */
        declarationParent: IrDeclarationParent?,
        param: IrValueParameter?,
        enclosingClass: IrClass?,
        receivedType: IrSimpleType?,
        targetType: IrType,
        builder: DeclarationIrBuilder,
        getRandomContextExpr: IrExpression,
        getRandomConfigExpr: IrExpression,
        optionalParamMetaDataForReporting: ReportData,
        randomFunctionMetaData: RandomFunctionMetaData,
    ): IrExpression {
        val actualParamType = receivedType ?: targetType
        val clazz = actualParamType.classOrNull?.owner

        if (clazz != null) {

            val randomInstanceExpr = generateRandomInstanceOfClass(
                declarationParent = declarationParent,
                receivedTypeArguments = receivedType?.arguments,
                param = param,
                enclosingClass = enclosingClass,
                irType = actualParamType,
                irClass = clazz,
                getRandomContextExpr = getRandomContextExpr,
                getRandomConfigExpr = getRandomConfigExpr,
                builder = builder,
                randomFunctionMetaData = randomFunctionMetaData,
            )

            if (randomInstanceExpr != null) {

                val nonNullRandom = builder.irBlock {
                    /**
                     * random instance from random context
                     */
                    val randomFromRandomContextCall =
                        getRandomContextExpr.extensionDotCall(randomContextAccessor.randomFunction(builder))
                            .withTypeArgs(actualParamType)

                    /**
                     * store random-from-context in a var because it will be used in 2 places:
                     * - a null check
                     * - else branch of an if-else below
                     */
                    val varRandomFromRandomContext =
                        irTemporary(randomFromRandomContextCall, "randomFromContext").apply {
                            this.type = actualParamType.makeNullable()
                        }

                    val getRandomFromRandomContext = irGet(varRandomFromRandomContext)

                    +irIfNull(
                        type = actualParamType,
                        subject = getRandomFromRandomContext,
                        thenPart = randomInstanceExpr,
                        elsePart = getRandomFromRandomContext
                    )
                }

                if (actualParamType.isNullable()) {
                    return randomOrNull(
                        builder = builder,
                        getRandomContext = getRandomConfigExpr,
                        type = actualParamType,
                        randomPart = nonNullRandom
                    )
                } else {
                    return randomOrThrow(
                        builder = builder,
                        randomExpr = nonNullRandom,
                        type = actualParamType,
                        optionalParamMetaDataForReporting,
                    )
                }
            } else {

                val paramNameText = param?.name?.let { "param $it:" } ?: ""

                throw IllegalArgumentException(
                    "unable to construct an expression to generate a random instance for $paramNameText${clazz.name}"
                )
            }
        } else {
            throw IllegalArgumentException("$targetType cannot provide a class.")
        }
    }

    /**
     * This is the case in which param type is generic, but does not receive any concrete type from the outside
     * This construct ane expr that pass the generic from random() function to [RandomContext] to get a random instance.
     */
    private fun generateRandomTypeForTypelessGeneric(
        receivedTypeClassifier: IrClassifierSymbol?,
        enclosingClass: IrClass?,
        param: IrValueParameter?,
        typeSymbol: IrTypeParameterSymbol,
        randomFunctionMetaData: RandomFunctionMetaData,
        targetType: IrType,
        builder: DeclarationIrBuilder,
        getRandomContextExpr: IrExpression,
        optionalParamMetaDataForReporting: ReportData,
    ): IrExpression {
        val paramTypeForRandomFunction = run {
            val actualTypeSymbol: IrTypeParameterSymbol =
                (receivedTypeClassifier as? IrTypeParameterSymbol) ?: typeSymbol
            val ptof: IrSimpleType? = randomFunctionMetaData.randomFunctionTypeList.getOrNull(actualTypeSymbol.owner.index)?.defaultType
            ptof.crashOnNull {
                "Can't find concrete type for ${targetType}. This is most likely a bug by the developer."
            }
        }

        val nonNullRandom = getRandomContextExpr.extensionDotCall(randomContextAccessor.randomFunction(builder))
            .withTypeArgs(paramTypeForRandomFunction)

        /**
         * use [isMarkedNullable] here because [isNullable] always returns true for generic type
         */
        val rt = if (targetType.isMarkedNullable()) {
            randomOrNull(
                builder = builder,
                getRandomContext = getRandomContextExpr,
                type = targetType,
                randomPart = nonNullRandom,
            )
        } else {
            return randomOrThrow(
                builder = builder,
                randomExpr = nonNullRandom,
                type = targetType,
                metaData = optionalParamMetaDataForReporting
            )
        }
        return rt
    }

    /**
     * Construct an express that:
     * - either return whatever [randomExpr] returns if such value is not null
     * - or throw an exception at runtime
     */
    private fun randomOrThrow(
        builder: DeclarationIrBuilder,
        randomExpr: IrExpression,
        type: IrType,
        metaData: ReportData,
    ): IrExpression {
        return builder.irBlock {
            val randomResult = irTemporary(randomExpr, "randomResult")
            val getRandomResult = irGet(randomResult)
            val throwExceptionExpr = throwUnableToRandomizeException(
                builder = this,
                msg = metaData.makeMsg(),
            )
            +irIfNull(type, getRandomResult, throwExceptionExpr, getRandomResult)
        }
    }

    /**
     * Construct and throw an instance of [UnableToMakeRandomException]
     */
    private fun throwUnableToRandomizeException(
        builder: IrBuilderWithScope, msg: String?
    ): IrThrowImpl {

        return with(builder) {
            irThrow(unableToMakeRandomExceptionAccessor.callConstructor(builder, msg))
        }
    }

    /**
     * TODO add logic to pick a constructor:
     *  - prioritize annotated constructors
     *  - pick randomly
     */
    private fun getConstructor(targetClass: IrClass): IrConstructor? {
        val primary = targetClass.primaryConstructor
        if (primary != null) {
            return primary
        } else {
            return null
        }
    }

    /**
     * Generate an [IrExpression] that will return a random value for a parameter ([param])
     */
    private fun generateRandomPrimitive(
        type: IrType,
        builder: DeclarationIrBuilder,
        /**
         * An expression that return a [RandomConfig]
         */
        getRandomContext: IrExpression,
        getRandomConfigExpr: IrExpression,
    ): IrExpression? {
        val isNullable = type.isNullable()
        val randomFunctionCall = when {
            type.isInt2(isNullable) -> randomConfigAccessor.nextInt(builder)
            type.isUInt2(isNullable) -> randomConfigAccessor.nextUInt(builder)
            type.isLong2(isNullable) -> randomConfigAccessor.nextLong(builder)
            type.isULong2(isNullable) -> randomConfigAccessor.nextULong(builder)
            type.isByte2(isNullable) -> randomConfigAccessor.nextByte(builder)
            type.isUByte2(isNullable) -> randomConfigAccessor.nextUByte(builder)
            type.isShort2(isNullable) -> randomConfigAccessor.nextShort(builder)
            type.isUShort2(isNullable) -> randomConfigAccessor.nextUShort(builder)
            type.isBoolean2(isNullable) -> randomConfigAccessor.nextBoolean(builder)
            type.isFloat2(isNullable) -> randomConfigAccessor.nextFloat(builder)
            type.isDouble2(isNullable) -> randomConfigAccessor.nextDouble(builder)
            type.isChar2(isNullable) -> randomConfigAccessor.nextChar(builder)
            type.isString2(isNullable) -> randomConfigAccessor.nextStringUUID(builder)
            type.isUnit2(isNullable) -> randomConfigAccessor.nextUnit(builder)
            type.isNumber2(isNullable) -> randomConfigAccessor.nextNumber(builder)
            type.isAny2(isNullable) -> randomConfigAccessor.nextAny(builder)
            type.isNothing2() -> throw IllegalArgumentException("impossible to randomize ${Nothing::class.qualifiedName}")
            else -> null
        }

        return randomFunctionCall?.let {
            randomFromRandomContextOrRandomConfig(
                type = type,
                getRandomContext = getRandomContext,
                randomFromConfigRandomExpr = getRandomConfigExpr.dotCall(randomFunctionCall),
                builder = builder,
            )
        }
    }


    private fun randomFromRandomContextOrRandomConfig(
        type: IrType, getRandomContext: IrExpression,
        /**
         * [randomFromConfigRandomExpr] return a random instance of [type]
         */
        randomFromConfigRandomExpr: IrExpression, builder: DeclarationIrBuilder
    ): IrExpression {
        val randomFromContext =
            getRandomContext.extensionDotCall(randomContextAccessor.randomFunction(builder)).withTypeArgs(type)
        val nonNullExpr = evaluateRandomContextThenRandomConfig(
            type = type,
            randomFromRandomContext = randomFromContext,
            randomFromRandomConfig = randomFromConfigRandomExpr,
            builder = builder,
        )
        if (type.isNullable()) {
            return randomOrNull(builder, getRandomContext, type, nonNullExpr)
        } else {
            return nonNullExpr
        }
    }

    private fun evaluateRandomContextThenRandomConfig(
        type: IrType,
        randomFromRandomContext: IrExpression,
        randomFromRandomConfig: IrExpression,
        builder: DeclarationIrBuilder,
    ): IrExpression {
        return builder.irBlock {

            val randomFromContextVar = irTemporary(
                value = randomFromRandomContext,
                nameHint = "randomFromContextVar",
                irType = type,
            )
            val getRandomFromContextVar = irGet(randomFromContextVar)

            +builder.irIfNull(
                type = type,
                subject = getRandomFromContextVar,
                thenPart = randomFromRandomConfig,
                elsePart = getRandomFromContextVar
            )
        }
    }

    private fun makeIrFunctionExpr(lambda: IrSimpleFunction, functionType: IrType): IrFunctionExpressionImpl {
        return IrFunctionExpressionImpl(
            startOffset = lambda.startOffset,
            endOffset = lambda.endOffset,
            type = functionType,
            function = lambda,
            origin = IrStatementOrigin.LAMBDA
        )
    }

    /**
     * Make a local lambda.
     */
    private fun makeLocalLambdaWithoutBody(
        /**
         * Return type of the lambda
         */
        returnType: IrType,
        beforeStandardConfig: IrFunctionBuilder.() -> Unit = {},
        afterStandardConfig: IrFunctionBuilder.() -> Unit = {},
    ): IrSimpleFunction {
        return pluginContext.irFactory.buildFun {
            beforeStandardConfig(this)
            name = SpecialNames.ANONYMOUS
            origin = BaseObjects.declarationOrigin
            visibility = DescriptorVisibilities.LOCAL
            this.returnType = returnType
            modality = FINAL
            isSuspend = false
            afterStandardConfig(this)
        }
    }

    private fun IrSimpleFunction.buildBody(configBuilder: IrSimpleFunction.(DeclarationIrBuilder) -> Unit): IrSimpleFunction {
        val builder = DeclarationIrBuilder(
            generatorContext = pluginContext,
            symbol = this.symbol,
        )
        this.configBuilder(builder)
        return this
    }

    private fun irPrintln(
        prefix: String,
        builder: IrBuilderWithScope,
        irExpr: IrExpression,
    ): IrCall {

        val typeAnyOrNull = pluginContext.irBuiltIns.anyNType
        val printlnFunction = pluginContext.referenceFunctions(BaseObjects.printlnCallId).firstOrNull {
            it.owner.valueParameters.let {
                it.size == 1 && it[0].type == typeAnyOrNull
            }
        }


        val strContent = builder.irConcat().apply {
            addArgument(builder.irString("$prefix:"))
            addArgument(irExpr)
        }

        val printlnCall = printlnFunction?.let {
            builder.irCall(it).apply {
                this.putValueArgument(0, strContent)
            }
        }
        return printlnCall!!
    }
}
