package com.x12q.randomizer.ir_plugin

import com.tschuchort.compiletesting.KotlinCompilation
import com.x12q.randomizer.lib.RandomConfig
import com.x12q.randomizer.ir_plugin.base.BaseObjects
import com.x12q.randomizer.lib.RandomizerCollection
import com.x12q.randomizer.test.util.assertions.isInstanceOf
import com.x12q.randomizer.test.util.assertions.runMain
import com.x12q.randomizer.test.util.test_code.ImportData
import io.kotest.matchers.nulls.shouldNotBeNull
import io.kotest.matchers.shouldBe
import org.jetbrains.kotlin.compiler.plugin.ExperimentalCompilerApi
import org.jetbrains.kotlin.ir.types.classFqName
import org.jetbrains.kotlin.ir.util.companionObject
import org.jetbrains.kotlin.ir.util.functions
import kotlin.test.Test

/**
 * This tests the existence of declarations generated by front end extension, which include:
 * - the random() functions
 *   - 2 non-generic random()
 *   - 2 generic random()
 */
@OptIn(ExperimentalCompilerApi::class)
class TopFrontEndDeclaration {
    @Test
    fun `random functions exist`() {

        val imports = ImportData.stdImport

        testGeneratedCodeUsingStandardPlugin(
            """
                ${imports}

                fun main(){
                    println(Q123.random())
                    println(Q123.random{})
                }

                @Randomizable(
                    randomConfig = DefaultRandomConfig::class
                )
                data class Q123(val i:Int){
                    companion object{
                          fun x12(randomizers: ${imports.nameOf(RandomizerCollection::class)}.() -> Unit = {}): Int {
                            return 123
                        }
                    }
                }
            """,
            fileName = "main.kt"
        ) {
            afterVisitClassNew = { irClass, statement, irPluginContext ->
                if (irClass.name.toString() == "Q123") {
                    val companionObj = irClass.companionObject()
                    companionObj.shouldNotBeNull()

                    /**
                     * test the existence of the first family of random() function
                     */
                    val randomFunction = companionObj.functions.firstOrNull { function->
                        val nameAndParamCountCondition = function.name == BaseObjects.randomFunctionName && function.valueParameters.size == 1
                        val firstParamIsCorrect = function.valueParameters.getOrNull(0)?.let { param->
                            param.isInstanceOf(Function1::class)
                        } ?: false
                        nameAndParamCountCondition && firstParamIsCorrect
                    }

                    randomFunction.shouldNotBeNull()
                    randomFunction.returnType.classFqName.toString() shouldBe "Q123"
                    randomFunction.body.shouldNotBeNull()


                    /**
                     * Test the existence of the 2nd random(randomConfig) function
                     */
                    val randomFunctionWithRandomConfig = companionObj.functions.firstOrNull {
                        it.name == BaseObjects.randomFunctionName && it.valueParameters.size == 1
                    }
                    randomFunctionWithRandomConfig.shouldNotBeNull()

                }
            }
            testCompilation = { result,_ ->
                result.exitCode shouldBe KotlinCompilation.ExitCode.OK
                result.runMain()
            }
        }
    }



    @Test
    fun `random functions with generics exist`() {

        testGeneratedCodeUsingStandardPlugin(
            """
                ${ImportData.stdImport}

                fun main(){
                }

                @Randomizable(
                    randomConfig = DefaultRandomConfig::class
                )
                data class Q123<T>(val i:Int,val t:T?)
            """,
            fileName = "main.kt"
        ) {
            afterVisitClassNew = { irClass, statement, irPluginContext ->
                if (irClass.name.toString() == "Q123") {
                    val companionObj = irClass.companionObject()
                    companionObj.shouldNotBeNull()

                    /**
                     * test the existence of the first random(randomT:()->T, ...) function
                     */
                    val randomFunction = companionObj.functions.firstOrNull { function->
                        val signatureOk = function.name == BaseObjects.randomFunctionName && function.valueParameters.size == 2
                        val params=function.valueParameters
                        val genericFunctionalParamsAreCorrect = params[0].let { param0->
                            param0.type.classFqName.toString() == kotlin.Function1::class.qualifiedName
                                    && param0.name.toString() == "randomT"
                        }
                        val randomizersBuilderFunctionIsCorrect = params[1].let {param1->
                            param1.type.classFqName.toString() == kotlin.Function1::class.qualifiedName
                                    && param1.name == BaseObjects.randomizersBuilderParamName
                        }
                        signatureOk && genericFunctionalParamsAreCorrect && randomizersBuilderFunctionIsCorrect
                    }

                    randomFunction.shouldNotBeNull()
                    randomFunction.returnType.classFqName.toString() shouldBe "Q123"
                    randomFunction.body.shouldNotBeNull()

                    /**
                     * Test the existence of the 2nd random(randomConfig,randomT:()->T, ...) function
                     */
                    val randomFunctionWithRandomConfig = companionObj.functions.firstOrNull {
                        val signatureIsOk = it.name == BaseObjects.randomFunctionName && it.valueParameters.size == 3
                        if(signatureIsOk){
                            val valueParamsAreCorrect = run {
                                val param1IsCorrect = it.valueParameters[0].type.classFqName.toString() == RandomConfig::class.qualifiedName
                                val param2IsCorrect = it.valueParameters[1].type.classFqName.toString() == kotlin.Function1::class.qualifiedName
                                param1IsCorrect && param2IsCorrect
                            }
                            valueParamsAreCorrect
                        }else{
                            false
                        }
                    }
                    randomFunctionWithRandomConfig.shouldNotBeNull()

                }
            }
            testCompilation = { result,_ ->
                result.exitCode shouldBe KotlinCompilation.ExitCode.OK
            }
        }
    }
}
